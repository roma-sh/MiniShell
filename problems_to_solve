								#DONE:
######################################################################################################
# case 1:

#$? (I need the status for the exit code). #:DONE

#I can clean and # Done: I can check for exit codes.

#exit codes :

#you can use the function change_status(t_env **mini_env, int status)
#anywhere you have an error to change the status

#echo "Hello, World!"
#echo $?  # Output: 0 : DONE

#ls nonexistentfile
#echo $?  # Output: 1 DONE

#exit 256
#echo $?  # Output: 2 DONE


#nonexistentcommand
#echo $?  # Output: 127 : DONE

#kill -9 $$
#echo $?  # Output: 137 (This will kill the shell, so you won't see this output)

#sleep 10
# Press Control-C during the sleep
#echo $?  # Output: 130 DONE

#exit 300
#echo $?  # Output: 255 , it is 44 DONE

# the status is not updating if the next command was executed successfully
# it must returned to 0 look at process_manager.c line 50 DONE


# Maybe in builtins there are some error cases which need to
# change the status also, I didn't check that DONE

#signals must be in the builtins also


#> out "ls
#check for seg fault".
######################################################################################################
								STILL:

/bin/ls /root  # Assuming you don't have permissions
echo $?  # Output: 126

create a function to free the envs.

cd to a sub-folder doesn't update PWD with the whole path, it only give /sub-folder-name

echo $hahahahahaha must print new line only
echo $?hahahaha must print 0hahahaha or exit_codehahahaha like 127hahahaha

